### This file was generated by Nexus Schema
### Do not make changes to this file directly


"""Result from calling candy machine upload logs"""
type CandyMachineUploadLogsResult {
  logs: JSON!

  """Process id handle"""
  processId: String!
}

"""Result from calling candy machine upload"""
type CandyMachineUploadResult {
  """the address that will be used to create the candy machine"""
  candyMachineAddress: String!

  """Process id handle"""
  processId: String!
}

"""The result for minting a NFT"""
type CreateFanoutResult {
  """Fanout public key"""
  fanoutPublicKey: String

  """Operation message"""
  message: String!

  """Solana address of the fanout"""
  solanaWalletAddress: String

  """Spl Fanout Details"""
  splFanout: [SplFanout]
}

"""The result for minting a NFT"""
type DisperseFanoutResult {
  """Operation message"""
  message: String!
}

"""
This is the input of an encrypted message, using public-key authenticated encryption to Encrypt and decrypt messages between sender and receiver using elliptic curve Diffie-Hellman key exchange.
"""
input EncryptedMessage {
  """Base58 Encoded Box"""
  boxedMessage: String!

  """Base58 Encoded Client public key used to box the message"""
  clientPublicKey: String!

  """Base58 Encoded nonce used for boxing the message"""
  nonce: String!
}

"""The result for decrypting"""
type EncryptedMessageResult {
  """Decrypted message"""
  message: String!
}

input FanoutMember {
  """Public key of member address"""
  publicKey: String!

  """Share member should receive"""
  shares: Float!
}

"""The `File` scalar type represents a file upload."""
scalar File

scalar JSON

"""The result for minting a NFT"""
type MintNftResult {
  """Mint hash of newly minted NFT"""
  message: String!
}

type Mutation {
  authenticatedMutation(encryptedMessage: EncryptedMessage!): EncryptedMessageResult
  candyMachineUpload(
    """Candy Machine Creation callback URL"""
    callbackUrl: String

    """Collection mint pubkey"""
    collectionMint: String!

    """Candy machine configuration"""
    config: JSON!

    """Solana env, either mainnet-beta | devnet | testnet"""
    env: String!

    """if set to true, the upload will execute synchronously"""
    executeSync: Boolean! = false

    """Zip file url with the assets"""
    filesZipUrl: String!

    """Campus GUID"""
    guid: String

    """Wallet keypair"""
    keyPair: String!

    """RPC To use, can point to devnet | mainnet"""
    rpc: String!

    """Set collection mint pubkey"""
    setCollectionMint: Boolean!

    """
    if set to true, the candy machine config will be modified to use hidden settings
    """
    useHiddenSettings: Boolean! = false
  ): CandyMachineUploadResult
  createFanout(
    """Wallet keypair"""
    keyPair: String!
    members: [FanoutMember]!

    """Fanout Name"""
    name: String!

    """
    Token mint addresses for which the fanout will create token accounts to distribute from, leave empty for a native SOL only fanout.
    """
    splTokenAddresses: [String]
  ): CreateFanoutResult
  disperseFanout(
    """Pubkey of Fanout to disperse"""
    fanoutPublicKey: String!

    """Payer keypair"""
    keyPair: String!

    """
    Token mint addresses for which the fanout will distribute from, leave empty for a native SOL only distribution
    """
    splTokenAddresses: [String]
  ): DisperseFanoutResult
  mintNft(keyPair: String!, mintToAddress: String, nftMetadata: NftMetadata, nftMetadataJSON: File): MintNftResult
  updateNft(
    """solana cluster name (i.e. devnet, mainnet-beta, testnet)"""
    cluster: String!

    """new NFT metadata json. Must provide either a newUri or newMetadtaJson."""
    newMetadataJson: NftMetadata

    """
    The nft will be updated with this metadata url. Must provide either a newUri or newMetadtaJson.
    """
    newUri: String

    """mint key for the NFT to update (base58 encoded string)"""
    nftMintId: String!

    """payer secret key, (base58 encoded string)"""
    payer: String!

    """update authority secret key, (base58 encoded string)"""
    updateAuthority: String!
  ): UpdateNftResult
}

input NftAttribute {
  """Name of the attribute"""
  trait_type: String

  """Value of the attribute"""
  value: String
}

input NftCreator {
  """creator address (pubkey base58)"""
  address: String

  """creator share in basis points"""
  share: Int
}

input NftFile {
  """Whether the file is hosted on the CDN"""
  cdn: Boolean

  """Type of the file"""
  type: String

  """URI of the file"""
  uri: String
}

"""Metadata for a NFT"""
input NftMetadata {
  """Animation URL of the NFT"""
  animation_url: String

  """Metadata for the NFT"""
  attributes: [NftAttribute]

  """Description of the NFT"""
  description: String!

  """External URL of the NFT"""
  external_url: String!

  """Image of the NFT"""
  image: String!

  """Name of the NFT"""
  name: String!

  """Properties of the NFT"""
  properties: NftProperties

  """Seller fee basis points"""
  seller_fee_basis_points: Int

  """Symbol of the NFT"""
  symbol: String!
}

input NftProperties {
  """Category of the NFT"""
  category: String

  """list of creators for this nft"""
  creators: [NftCreator]

  """Files associated with the NFT"""
  files: [NftFile]
}

type Query {
  """Get logs for a candy machine upload process"""
  candyMachineUploadLogs(
    """Process id handle"""
    processId: String!
  ): CandyMachineUploadLogsResult
}

"""The spl fanout result"""
type SplFanout {
  """SPL Token Address"""
  splTokenAddress: String!

  """SPL Token Wallet"""
  splTokenWallet: String!
}

"""The result for updating an NFT"""
type UpdateNftResult {
  """a descriptive message"""
  message: String!

  """uri of uploaded JSON metadata, if one was uploaded"""
  newUri: String

  """process id of the request which can be used to get logs"""
  processId: String!

  """true if nft update succeeded, false otherwise"""
  success: Boolean!
}